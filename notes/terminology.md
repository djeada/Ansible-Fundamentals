## Ansible Terminologies

| **Term**       | **Definition**                                                                                                                                                                         |
|----------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Inventory**       | The primary file defining all the remote hosts and groups that Ansible manages. It tells Ansible where to execute commands, modules, and playbook tasks.                                                     |
| **Host**            | An individual remote system listed in the inventory that Ansible can manage.                                                                                                                                |
| **Groups**          | Logical collections of hosts defined in the inventory or group variable files, allowing you to apply common variables and configurations to multiple hosts at once.                                     |
| **Dynamic Inventory** | A mechanism that generates up-to-date host lists using scripts or plugins at runtime instead of relying on static inventory files, ensuring your host list reflects changes in your environment.         |
| **Playbooks** | YAML-formatted files that organize a sequence of plays, where each play maps a group of hosts to tasks. They serve as the blueprint for the configuration, deployment, and orchestration of complex systems.                        |
| **Tasks**     | The smallest units of work in a playbook. Each task runs a module to perform a single, specific action—such as installing a package or configuring a service—toward achieving a larger goal.                                          |
| **Blocks**    | Containers used to group multiple tasks within a playbook. Blocks allow you to apply conditionals, loop controls, or error handling strategies (like rescue or always sections) to the entire group rather than individually.         |
| **Handlers**  | Special tasks that run only when notified by other tasks. They are typically used for service restarts or reloads, ensuring that changes are applied only when necessary.                                                              |
| **Tags**      | Labels assigned to tasks, blocks, or roles. Tags allow you to selectively execute or skip parts of a playbook, which is especially useful for testing or partial updates.                                                               |
| **Roles**     | Reusable automation components that encapsulate related playbook elements like tasks, handlers, variables, templates, and files into a defined directory structure. Roles promote modularity and code reusability.                    |
| **Include vs Import** | Directives for incorporating external content into a playbook. "Import" includes tasks at parse time, while "include" executes the inserted tasks at runtime, allowing dynamic inclusion and control over task execution order.     |
| **Modules**    | Standalone scripts that execute specific functions (such as installing a package or creating a file). They are the workhorses of Ansible and can be invoked directly via the command line or through playbook tasks.                                  |
| **Library**    | A collection of built-in modules provided by Ansible that can be directly executed on remote hosts or referenced in playbooks, forming the core functionality of Ansible’s automation capabilities.                                                      |
| **Actions**    | The operations performed by action plugins in tandem with modules. They interpret task requirements and determine the correct sequence of module invocations and parameter adjustments.                                                                  |
| **Notify**     | A mechanism by which tasks signal handlers to execute. When a task changes something and uses the notify directive, any associated handlers will run at the end of the play, ensuring actions such as restarts occur only when needed.                    |
| **Callbacks**  | Plugins that allow modification or enhancement of Ansible output (e.g., changing the display or logging format) to provide customized feedback during or after task execution.                                                                             |
| **Ad-hoc**     | One-time commands executed from the command line for quick operations rather than through a full playbook. They are ideal for small tasks or troubleshooting individual hosts without writing a playbook.                                             |
| **Variables**   | Named placeholders used to store data that can be reused throughout playbooks and roles. Variables can be defined in playbooks, inventory files, roles, or loaded from external sources to customize playbook behavior dynamically.              |
| **Facts**       | Automatically collected data about target systems, such as network settings, installed packages, and operating system details. These provide contextual information about hosts during playbook execution.                                     |
| **Fact Caching**| A mechanism to store gathered facts between playbook runs, speeding up subsequent executions by avoiding repeated fact collection from remote hosts.                                                                                                |
| **Lookups**     | Functions used to retrieve data from external sources (files, databases, or other storage systems) at runtime, enabling dynamic variable assignment or template population based on changing external data.                                       |
| **Templates**   | Text files (typically with a .j2 extension) crafted using the Jinja2 templating language. They enable dynamic content generation by integrating variables and logic into configuration files, scripts, or other text-based formats.              |
| **Filters**     | Jinja2 operations applied to variables within templates, used to transform or format data (e.g., converting strings to uppercase or formatting dates) before they are rendered in task outputs.                                               |
| **YAML**        | A human-readable data serialization format used extensively in Ansible for playbooks, inventory files, and variable definitions. Originally standing for “Yet Another Markup Language”, it is optimized for clarity and simplicity in configuration. |
| **Orchestration**| The process of defining and managing your infrastructure as code. It enables you to deploy, manage, and integrate multiple systems consistently and reliably using a single declarative source of truth.                                 |
| **Push mode**    | An operational mode where Ansible pushes configuration and changes from a central control machine to managed nodes without requiring any agent software on those nodes.                                                                   |
| **Pull mode**    | An operational mode (utilized by Ansible-pull) where each managed node periodically pulls its configuration from a central repository. A local copy of Ansible is maintained on the node and run via a scheduled cron job or similar method. |
| **Conditionals** | Expressions that determine whether a task or block of tasks should be executed. They help tailor the playbook’s behavior dynamically based on the state or properties of the target systems.                                                         |
| **Error Handling** | Mechanisms built into playbooks—using constructs like “rescue” and “always” blocks—to manage task failures gracefully. They allow you to specify alternative actions or clean-up steps when errors occur during execution.                          |
| **Vault**  | A built-in Ansible feature that encrypts sensitive data (e.g., passwords, keys) within files. This ensures that even if playbooks or variable files are shared, confidential information remains secure and only accessible with the proper decryption key.         |
Below is an expanded table that includes additional Ansible concepts. Each new row is designed to complement the previous definitions, further detailing advanced features and mechanisms found in Ansible.
| **Collections**      | A standardized distribution format that packages Ansible roles, modules, plugins, and other automation content. Collections simplify sharing and reuse across projects and communities by bundling related artifacts together.                                                                                     |
| **Connection Plugins** | Plugins that manage how Ansible connects to remote systems. They support various protocols such as SSH, WinRM, and local connections, ensuring that tasks are executed reliably on different target environments.                                                                                                          |
| **Delegate_to**      | A mechanism that allows a task to run on a host different from the one specified in the play. This feature is useful for centralizing certain operations or when tasks need to be executed on a control node or another designated machine.                                                                          |
| **Become**           | A feature that enables privilege escalation during task execution. It allows tasks to run as another user (typically root) so that operations requiring higher permissions on the target system can be performed securely and effectively.                                                                             |
| **Asynchronous Tasks** | A method for executing tasks that might take longer to complete. Ansible triggers the task asynchronously and periodically checks for its completion, permitting the control node to continue processing other tasks concurrently and avoiding unnecessary waiting.                                                       |
| **Ansible Galaxy**   | The official community hub for discovering, sharing, and downloading Ansible roles and collections. It facilitates the reuse of automation components, making it easier for users to adopt best practices and integrate community-driven content into their workflows.                                           |
| **Loop Control**     | Mechanisms that enable repetitive execution of a single task with different inputs. Commonly implemented using constructs like `with_items` or the `loop` directive, loop control allows for efficient handling of repetitive actions within playbooks.                                                              |
| **Strategy Plugins** | Plugins that dictate the execution order of tasks across hosts. While the default strategy executes tasks sequentially (linear execution), alternative strategies can facilitate parallel processing or custom ordering, thereby optimizing performance in large or complex playbooks.                                   |
| **Module Utils**     | A collection of helper functions used by Ansible modules to perform common operations. These utilities streamline module development and maintain consistency in functionality across different modules by providing a shared library of code and standards.                                                  |

